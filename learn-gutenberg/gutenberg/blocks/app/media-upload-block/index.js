import block_icons from '../icons/index';
import './editor.scss';

const { registerBlockType }         =   wp.blocks;
const { Button, Dashicon }          =   wp.components;
const { __ }                        =   wp.i18n;

// Компонент загрузки мультимедиа (MediaUpload) создаст пользовательский интерфейс для выбора и загрузки изображений в
// загрузчик мультимедиа. Компонент проверки загрузки мультимедиа (MediaUploadCheck) делает кое-что отличающееся от
// любого другого компонента, с которыми мы сталкивались до сих пор. Этот компонент был специально создан для проверки
// того, имеет ли пользователь, вошедший в систему, права и разрешения для загрузки и управления файлами. Этот компонент
// должен быть обернут вокруг компонента загрузки мультимедиа.
const { MediaUpload, MediaUploadCheck } = wp.editor;

registerBlockType( 'udemy/media-upload', {
    title:                              __( 'Image Media Upload', 'recipe' ),
    description:                        __( 'Image Media Upload', 'recipe' ),
    category:                           'common',
    icon:                               block_icons.wapuu,

    // Блок будет зависеть от того, что будет возвращено загрузчиком мультимедиа, а также от ID, URL-адреса и
    // альтернативного текста.
    attributes: {
        //  Начнем с ID. Именем укажем img_ID. Типом укажем number. Идентификатором будет идентификатор элемента мультимедиа,
        //  который будет храниться в базе данных. Мы не будем его в этот раз использовать, но эти сведения все равно могут
        //  понадобиться. Я также не собираюсь хранить его в элементе. Вместо этого я сохраню эти данные в комментариях.
        img_ID: {
            type: 'number'
        },
        //  Далее идет URL изображения. Типом укажем string, а в качестве источника – attribute. Иными словами, мы говорим
        //  WordPress, что значение можно найти внутри атрибута, когда он загружает HTML из базы данных. Если вы
        //  устанавливаете для источника значение атрибута, тогда затем вам нужно будет установить свойство атрибута.
        //  Это позволит вам указать атрибут, в котором хранится значение. Установим в качестве атрибута, в котором
        //  хранится значение “src”. Мы будем использовать тег изображения. Было бы разумно сохранить URL там.
        img_URL: {
            type: 'string',
            source: 'attribute',
            attribute: 'src',
            selector: 'img'
        },
        // Это копия img_URL, за исключением того, что в качестве атрибута будет установлено “alt”.
        img_alt: {
            type: 'string',
            source: 'attribute',
            attribute: 'alt',
            selector: 'img'
        }
    },
    edit: ( props ) => {
        // Для атрибута onSelect компонента загрузчика мультимедиа MediaUpload мы укзаали вызов функции select_img.
        // Функции мы передадим объект с названием img. Этот объект будет содержать свойства и значения, относящиеся к
        // изображению, выбранному в загрузчике мультимедиа. С помощью этого объекта я собираюсь присвоить каждому
        // атрибуту соответствующее свойство. Чтобы это сделать, я вызываю функцию setAttributes.
        const select_img = (img) => {
            props.setAttributes({
                img_ID: img.id,
                img_URL: img.url,
                img_alt: img.alt
            })
        };

        // Функция remove_img (на нее ссылается событие onClick элемента кнопки удаления изображения) сходна функции
        // select_img, за исключением того, что для всех атрибутов устанавливается значение null.
        const remove_img = () => {
            props.setAttributes({
                img_ID: null,
                img_URL: null,
                img_alt: null
            })
        };

        return (
            <div className={props.className}>
                {/*Здесь нам нужно будет отобразить кнопку, которая отобразит загрузчик мультимедиа. Вот в чем проблема:
                мы хотим отображать кнопку только в том случае, если в данный момент не отображается никакого медиа.
                Мы бы хотели использовать для этого условный оператор, но мы не можем использовать обычные условные операторы
                внутри JSX. Вместо этого нам придется использовать тернарный оператор. Я собираюсь проверить, установлена
                ли переменная props.attributes.img_ID. Если это так, мы отобразим изображение. В противном случае мы отобразим
                кнопку для загрузчика мультимедиа. */}
                {props.attributes.img_ID ? (
                    // Здесь происходит отображение изображения. Это секция, которая будет выполняться, если будет истинно
                    // условие, заключающееся в наличии переменной ID изображения. Я собираюсь обернуть все тегом div.
                    // Контейнер должен иметь класс “image-ctr”. Внутри тег изображения с атрибутами источника и альтернативного
                    // текста. Для них установлены соответствующие значения атрибутов.
                    <div className="image-ctr">
                        <img src={props.attributes.img_URL}
                             alt={props.attributes.img_alt}/>
                        {/*Нам нужно добавить кнопку, которая удалит изображение, если пользователь кликнет по этой кнопке.
                        Для этого мы будем использовать другой тернарный оператор. Мы хотим отобразить кнопку только в том
                        случае, если блок выбран в данный момент. Это еще одно дизайнерское решение относительно пользовательского
                        интерфейса. Если пользователь редактирует блок, то имеет смысл отобразить параметры, связанные с
                        редактированием блока. Однако, если блок не выбран, мы хотим скрыть параметры, чтобы предотвратить
                        добавление беспорядка в интерфейс. Мы собираемся проверить, истинно ли свойство props.isSelected.
                        Напомню, что это свойство WordPress автоматически обновит в случае, если блок редактируется.
                        Если значение будет истинным, мы отобразим компонент кнопки. Я применяю класс “btn-remove” и
                        устанавливаю для события onClick (при клике) функцию удаления изображения. Чтобы завершить работу,
                        нам нужно будет определить вторую половину тернарного оператора, как null, чтобы ничего не отображать,
                        если блок не выбран. */}
                        {props.isSelected ? (
                            <Button className="btn-remove" onClick={remove_img}>
                                {/*Для содержимого внутри я собираюсь добавить компонент DashIcon. У нас есть возможность
                                добавить в свой собственный значок SVG, но я думаю, что здесь будет достаточно набора значков
                                DashIcon. Вы можете использовать любой из значков DashIcon, предоставляемых WordPress. Все,
                                что вам нужно сделать, это добавить атрибут значка, и передать имя значка, который вы хотели
                                бы использовать. Вам не нужно добавлять префикс dashicon-, так как он будет добавлен автоматически.
                                Мы будем использовать значок "no", который представляет собой знак x (крестик). Я также
                                собираюсь установить атрибут size равным 20. Это размер в пикселях, который будет определять
                                размер кнопки. Она имеет абсолютное позиционирование. Проверьте файл editor.scss. */}
                                <Dashicon icon='no' size="20" />
                            </Button>
                        ) : null}
                    </div>
                ) : (
                    // Выведем компоненты проверки загрузчика мультимедиа (media upload check) и компонент загрузчика мультимедиа
                    // (media upload). Я оберну компонент загрузчика мультимедиа компонентом проверки загрузчика мультимедиа.
                    // Это необходимо, если вы хотите ограничить, кто может, а кто не может загружать изображения. Вам не
                    // требуется передавать какой-то специальный атрибут компоненту проверки загрузчика мультимедиа. Он
                    // уже правильно сконфигурирован.
                    <MediaUploadCheck>
                        <MediaUpload
                            // Первый атрибут, который мы определим, будет устанавливать разрешенные типы файлов. Здесь
                            // нужно указать массив типов файлов, которые мы хотели бы разрешить к загрузке. Мы хотим разрешить
                            // только один тип файла - изображение. Это необязательный параметр, но если его установить,
                            // WordPress будет ограничивать возможности пользователя выбирать определенные типы файлов.
                            // Мы хотим разрешить пользователям выбирать только изображения.
                            allowedType={['image']}
                            // Далее нам нужно будет установить атрибут value. Установим для value значение
                            // props.attributes.img_ID. Если передать значение, WordPress автоматически выберет элемент
                            // мультимедиа с таким ID. Таким образом, пользователю не нужно будет прокручивать страницу,
                            // чтобы найти элемент мультимедиа, который он ранее выбрал.
                            value={props.attributes.img_ID}
                            // Следующий атрибут - onSelect. Установим для этого параметра select_img. Это событие, которое
                            // будет вызвано, когда пользователь выберет изображение. Значением этого атрибута должна быть
                            // функция, которая будет обрабатывать изображение, которое мы передаем.
                            onSelect={select_img}
                            // Render, отрисовщик - это атрибут, который используется для отображения кнопки, которая
                            // будет открывать загрузчик мультимедиа. Компонент загрузчика мультимедиа не будет сразу
                            // отображать загрузчик мультимедиа. Вместо этого загрузчик мультимедиа отображается, когда
                            // происходит вызов определенной функции. Компонент загрузчика мультимедиа дает нам возможность
                            // создать эту кнопку самостоятельно. Значением этого атрибута будет анонимная функция, которой
                            // будет передан объект. Нас интересует только одно свойство этого объекта - это функция open.
                            // Деструктурируем ее. Функция open откроет загрузчик мультимедиа. Теперь давайте создадим кнопку
                            // с помощью компонента Button. Я применяю классы button и button-large. Текстом внутри будет
                            // “Upload Image”. Теперь давайте установим для события onСlick вызов функции open.

                            // Вот что должно произойти. Компонент загрузчика мультимедиа отобразит кнопку, которую мы
                            // создали в атрибуте рендеринга. Кнопка осуществит вызов функции открытия (open) при срабатывании
                            // события клика (onClick). Функция open при ее вызове позаботится об отображении загрузчика
                            // мультимедиа. Прежде чем мы начнем отображать изображение после того, как оно было выбрано,
                            // нам нужно будет сохранить данные изображения. Для атрибута onSelect мы укзаали вызов функции
                            // select_img.
                            render={({open}) => (
                                <Button className={"button button-large"} onClick={open}>
                                    {__('Upload Image', 'recipe')}
                                </Button>
                            )}
                        ></MediaUpload>
                    </MediaUploadCheck>
                )};
            </div>
        )
    },
    save: ( props ) => {
        return (
            <div>
                <img src={props.attributes.img_URL}
                     alt={props.attributes.img_alt}/>
            </div>
        )
    }
});